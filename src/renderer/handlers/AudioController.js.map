{"version":3,"file":"AudioController.js","sourceRoot":"","sources":["AudioController.ts"],"names":[],"mappings":";AAAA,0DAA0D;AAC1D,0CAA0C;AAC1C,oEAAoE;AACpE,0GAA0G;AAE1G,+DAA+D;AAC/D,8BAA8B;AAC9B,wBAAwB;AAExB,wBAAwB;AACxB,6CAA6C;AAC7C,mCAAmC;AACnC,6BAA6B;AAC7B,6BAA6B;AAC7B,iBAAiB;AACjB,6BAA6B;AAC7B,OAAO;AAEP,sFAAsF;AAEtF,4CAA4C;AAC5C,KAAK;AAEL,2DAA2D;AAC3D,yCAAyC;AACzC,8DAA8D;AAC9D,iDAAiD;AACjD,yCAAyC;AAEzC,wCAAwC;AACxC,4DAA4D;AAC5D,uCAAuC;AACvC,wCAAwC;AACxC,2DAA2D;AAE3D,2BAA2B;AAC3B,qCAAqC;AACrC,kCAAkC;AAClC,yBAAyB;AACzB,2BAA2B;AAE3B,yBAAyB;AACzB,uBAAuB;AACvB,8BAA8B;AAC9B,yBAAyB;AACzB,iCAAiC;AACjC,sCAAsC;AACtC,2BAA2B;AAC3B,kEAAkE;AAClE,uEAAuE;AACvE,uEAAuE;AACvE,6CAA6C;AAE7C,aAAa;AACb,uBAAuB;AACvB,4BAA4B;AAC5B,qCAAqC;AACrC,WAAW;AACX,UAAU;AACV,iBAAiB;AACjB,OAAO;AACP,KAAK;AAEL,mCAAmC;AACnC,sGAAsG;AACtG,4DAA4D;AAC5D,oDAAoD;AACpD,aAAa;AACb,MAAM;AACN,6CAA6C;AAC7C,0CAA0C;AAC1C,4CAA4C;AAC5C,sCAAsC;AAEtC,+EAA+E;AAC/E,qEAAqE;AACrE,0CAA0C;AAC1C,0BAA0B;AAC1B,2BAA2B;AAC3B,aAAa;AAEb,2BAA2B;AAC3B,2BAA2B;AAC3B,aAAa;AAEb,2BAA2B;AAC3B,2BAA2B;AAE3B,gDAAgD;AAChD,0BAA0B;AAC1B,4BAA4B;AAC5B,QAAQ;AAER,oDAAoD;AACpD,iDAAiD;AACjD,4BAA4B;AAC5B,QAAQ;AAER,aAAa;AAEb,gCAAgC;AAChC,uBAAuB;AACvB,2BAA2B;AAE3B,oDAAoD;AACpD,iDAAiD;AACjD,4BAA4B;AAC5B,QAAQ;AACR,aAAa;AAEb,6BAA6B;AAC7B,cAAc;AACd,2BAA2B;AAC3B,aAAa;AACb,MAAM;AAEN,uEAAuE;AACvE,uEAAuE;AACvE,kEAAkE;AAClE,KAAK;AAEL,oDAAoD;AACpD,8DAA8D;AAC9D,wEAAwE;AACxE,KAAK;AAEL,qDAAqD;AACrD,uCAAuC;AACvC,aAAa;AACb,MAAM;AACN,2DAA2D;AAC3D,oDAAoD;AACpD,qDAAqD;AACrD,uEAAuE;AACvE,8CAA8C;AAC9C,eAAe;AACf,qBAAqB;AACrB,uBAAuB;AACvB,4DAA4D;AAC5D,mCAAmC;AACnC,4CAA4C;AAC5C,oCAAoC;AACpC,KAAK;AAEL,gDAAgD;AAChD,sBAAsB;AACtB,6DAA6D;AAC7D,8CAA8C;AAC9C,mBAAmB;AACnB,eAAe;AACf,qDAAqD;AACrD,6BAA6B;AAC7B,SAAS;AACT,SAAS;AACT,KAAK;AACL,IAAI;AAEJ,wDAAwD","sourcesContent":["// import { EventEmitter as EventEmitterO } from 'events';\r\n// import * as io from 'socket.io-client';\r\n// import { AmongUsState, GameState, Player } from './AmongUsState';\r\n// import { SocketElementMap, SocketElement, Client, AudioElement, IDeviceInfo } from './smallInterfaces';\r\n\r\n// export default class AudioController extends EventEmitterO {\r\n// \taudioDeviceId = 'default';\r\n// \tstream: MediaStream;\r\n\r\n// \tasync startAudio() {\r\n// \t\tconst audio: MediaTrackConstraintSet = {\r\n// \t\t\tdeviceId: this.audioDeviceId,\r\n// \t\t\tautoGainControl: false,\r\n// \t\t\techoCancellation: true,\r\n// \t\t\tlatency: 0,\r\n// \t\t\tnoiseSuppression: true,\r\n// \t\t};\r\n\r\n// \t\tthis.stream = await navigator.mediaDevices.getUserMedia({ video: false, audio });\r\n\r\n// \t\tconsole.log('connected to microphone');\r\n// \t}\r\n\r\n// \tcreateAudioElement(stream: MediaStream): AudioElement {\r\n// \t\tconsole.log('[createAudioElement]');\r\n// \t\tconst htmlAudioElement = document.createElement('audio');\r\n// \t\tdocument.body.appendChild(htmlAudioElement);\r\n// \t\thtmlAudioElement.srcObject = stream;\r\n\r\n// \t\tconst context = new AudioContext();\r\n// \t\tconst source = context.createMediaStreamSource(stream);\r\n// \t\tconst gain = context.createGain();\r\n// \t\tconst pan = context.createPanner();\r\n// \t\tconst compressor = context.createDynamicsCompressor();\r\n\r\n// \t\tpan.refDistance = 0.1;\r\n// \t\tpan.panningModel = 'equalpower';\r\n// \t\tpan.distanceModel = 'linear';\r\n// \t\tpan.maxDistance = 6;\r\n// \t\tpan.rolloffFactor = 1;\r\n\r\n// \t\tsource.connect(pan);\r\n// \t\tpan.connect(gain);\r\n// \t\tgain.connect(compressor);\r\n// \t\tgain.gain.value = 0;\r\n// \t\thtmlAudioElement.volume = 1;\r\n// \t\tconst audioContext = pan.context;\r\n// \t\tconst panPos = [3, 0];\r\n// \t\tpan.positionZ.setValueAtTime(-0.5, audioContext.currentTime);\r\n// \t\tpan.positionX.setValueAtTime(panPos[0], audioContext.currentTime);\r\n// \t\tpan.positionY.setValueAtTime(panPos[1], audioContext.currentTime);\r\n// \t\tcompressor.connect(context.destination);\r\n\r\n// \t\treturn {\r\n// \t\t\thtmlAudioElement,\r\n// \t\t\taudioContext: context,\r\n// \t\t\tmediaStreamAudioSource: source,\r\n// \t\t\tgain,\r\n// \t\t\tpan,\r\n// \t\t\tcompressor,\r\n// \t\t};\r\n// \t}\r\n\r\n// \t// move to different controller\r\n// \tupdateAudioLocation(currentGameState: AmongUsState, element: SocketElement, localPLayer: Player) {\r\n// \t\t//\t\tconsole.log('updateAudioLocation ->', { element });\r\n// \t\tif (!element.audioElement || !element.client) {\r\n// \t\t\treturn;\r\n// \t\t}\r\n// \t\t//\tconsole.log('[updateAudioLocation]');\r\n// \t\tconst pan = element.audioElement.pan;\r\n// \t\tconst gain = element.audioElement.gain;\r\n// \t\tconst audioContext = pan.context;\r\n\r\n// \t\tconst other = element.player; // this.getPlayer(element.client?.clientId);\r\n// \t\tlet panPos = [other.x - localPLayer.x, other.y - localPLayer.y];\r\n// \t\tswitch (currentGameState.gameState) {\r\n// \t\t\tcase GameState.MENU:\r\n// \t\t\t\tgain.gain.value = 0;\r\n// \t\t\t\tbreak;\r\n\r\n// \t\t\tcase GameState.LOBBY:\r\n// \t\t\t\tgain.gain.value = 1;\r\n// \t\t\t\tbreak;\r\n\r\n// \t\t\tcase GameState.TASKS:\r\n// \t\t\t\tgain.gain.value = 1;\r\n\r\n// \t\t\t\t// Mute other players which are in a vent\r\n// \t\t\t\tif (other.inVent) {\r\n// \t\t\t\t\tgain.gain.value = 0;\r\n// \t\t\t\t}\r\n\r\n// \t\t\t\t// Mute dead players for still living players\r\n// \t\t\t\tif (!localPLayer.isDead && other.isDead) {\r\n// \t\t\t\t\tgain.gain.value = 0;\r\n// \t\t\t\t}\r\n\r\n// \t\t\t\tbreak;\r\n\r\n// \t\t\tcase GameState.DISCUSSION:\r\n// \t\t\t\tpanPos = [0, 0];\r\n// \t\t\t\tgain.gain.value = 1;\r\n\r\n// \t\t\t\t// Mute dead players for still living players\r\n// \t\t\t\tif (!localPLayer.isDead && other.isDead) {\r\n// \t\t\t\t\tgain.gain.value = 0;\r\n// \t\t\t\t}\r\n// \t\t\t\tbreak;\r\n\r\n// \t\t\tcase GameState.UNKNOWN:\r\n// \t\t\tdefault:\r\n// \t\t\t\tgain.gain.value = 0;\r\n// \t\t\t\tbreak;\r\n// \t\t}\r\n\r\n// \t\tpan.positionX.setValueAtTime(panPos[0], audioContext.currentTime);\r\n// \t\tpan.positionY.setValueAtTime(panPos[1], audioContext.currentTime);\r\n// \t\tpan.positionZ.setValueAtTime(-0.5, audioContext.currentTime);\r\n// \t}\r\n\r\n// \tdisconnect(socketElementmap: SocketElementMap) {\r\n// \t\tthis.stream.getTracks().forEach((track) => track.stop());\r\n// \t\tsocketElementmap.forEach((value) => this.disconnectElement(value));\r\n// \t}\r\n\r\n// \tdisconnectElement(socketElement: SocketElement) {\r\n// \t\tif (!socketElement.audioElement) {\r\n// \t\t\treturn;\r\n// \t\t}\r\n// \t\tsocketElement?.audioElement?.compressor?.disconnect();\r\n// \t\tsocketElement?.audioElement?.pan?.disconnect();\r\n// \t\tsocketElement?.audioElement?.gain?.disconnect();\r\n// \t\tsocketElement?.audioElement?.mediaStreamAudioSource?.disconnect();\r\n// \t\tsocketElement?.audioElement?.audioContext\r\n// \t\t\t?.close()\r\n// \t\t\t.then(() => {})\r\n// \t\t\t.catch(() => {});\r\n// \t\tsocketElement?.audioElement?.htmlAudioElement.remove();\r\n// \t\tsocketElement.peer?.destroy();\r\n// \t\tsocketElement.audioElement = undefined;\r\n// \t\tsocketElement.peer = undefined;\r\n// \t}\r\n\r\n// \tasync getDevices(): Promise<IDeviceInfo[]> {\r\n// \t\tlet deviceId = 0;\r\n// \t\treturn (await navigator.mediaDevices.enumerateDevices())\r\n// \t\t\t.filter((o) => o.kind === 'audiooutput')\r\n// \t\t\t.map((o) => {\r\n// \t\t\t\treturn {\r\n// \t\t\t\t\tlabel: o.label || `Microphone ${deviceId++}`,\r\n// \t\t\t\t\tdeviceId: o.deviceId,\r\n// \t\t\t\t};\r\n// \t\t\t});\r\n// \t}\r\n// }\r\n\r\n// export const audioController = new AudioController();\r\n"]}